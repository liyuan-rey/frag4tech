# PostgreSQL 数据库设计和开发指南

> 适用于 PostgreSQL 11 及以上版本

- [1. 设计原则](#1-设计原则)
  - [1.1. 关于范式](#11-关于范式)
  - [1.2. 字符集](#12-字符集)
  - [1.3. 表空间](#13-表空间)
  - [1.4. 表](#14-表)
  - [1.5. 分区表](#15-分区表)
  - [1.6. 视图](#16-视图)
  - [1.7. 物化视图](#17-物化视图)
  - [1.8. 索引](#18-索引)
  - [1.9. 主键](#19-主键)
  - [1.10. 外键](#110-外键)
  - [1.11. NULL 值](#111-null-值)
- [2. 命名规范](#2-命名规范)
  - [2.1. 命名原则](#21-命名原则)
  - [2.2. 数据库实例](#22-数据库实例)
  - [2.3. 表空间](#23-表空间)
  - [2.4. 数据库连接](#24-数据库连接)
  - [2.5. 表](#25-表)
  - [2.6. 视图](#26-视图)
  - [2.7. 字段](#27-字段)
  - [2.8. 主键约束](#28-主键约束)
  - [2.9. 外键约束](#29-外键约束)
  - [2.10. 唯一性约束（Constraint）](#210-唯一性约束constraint)
  - [2.11. NOT NULL 约束（Constraint）](#211-not-null-约束constraint)
  - [2.12. Check 约束（Constraint）](#212-check-约束constraint)
  - [2.13. 索引](#213-索引)
  - [2.14. 函数](#214-函数)
- [3. 开发规范](#3-开发规范)
- [4. 数据类型使用约定](#4-数据类型使用约定)
- [5. 参考资料](#5-参考资料)

## 1. 设计原则

### 1.1. 关于范式

如无性能上的必须原因，应该使用关系数据库理论，达到较高的范式匹配（3NF），避免数据冗余，明确数据关系。

如果对性能有较高要求，或者在特定场景达成业务目标的便利性收益高于数据维护影响，可以设计适当的突破范式要求。

如非确实必要，避免一个字段中存储多个标志的做法。如 `11101` 数值中每个数字分别代表 5 个标志位的取值。这对数据库查询来说往往是增加复杂度，降低性能的地方。

### 1.2. 字符集

字符集编码采用 `UTF-8`，（PostgreSQL 默认）。

### 1.3. 表空间

PostgreSQL 中的表空间与 Oracle 中不一样，创建表空间只要指定名称与数据库文件的目录，而没有具体的大小。

PostgreSQL 表空间不适用自动扩容这个概念，可以通过扩展存储容量，或者在不同存储设备/分区中新建表空间并指定新表使用新表空间来达到扩容目的。

应当考虑表空间设计，默认表空间 `pg_default` 有时并不是恰当选择。

表空间的名称不能以 'pg_' 开头，它们是系统表空间的保留名称。

表空间大小大于操作系统对最大文件限制时，该表空间由多个数据文件组成。

PostgreSQL 查看数据库占用的物理存储空间大小：https://www.cnblogs.com/mchina/archive/2013/04/19/3028573.html

### 1.4. 表

对于表中含有大对象字段，如BLOB, CLOB, NCLOB, 应考虑把这些对象放到独立的表空间，这样有利于提高查询效率。

PostgreSQL 社区版没有“内存表”的功能，可以考虑用 `unlogged table` 实现类似功能：https://developer.aliyun.com/article/698151

当需要经常取表中的特定数据时，可以使用 PostgreSQL 的聚簇索引功能提高 IO 效率。http://postgres.cn/docs/13/sql-cluster.html

### 1.5. 分区表

分区表有一些优点:

- 增强可用性：如果表的一个分区由于系统故障而不能使用，表的其余好的分区仍然可以使用；
- 减少关闭时间：如果系统故障只影响表的一部分分区，那么只有这部分分区需要修复，故能比整个大表修复花的时间更少；
- 维护轻松：如果需要重建表，独立管理每个分区比管理单个大表要轻松得多；
- 均衡I/O:可以把表的不同分区分配到不同的磁盘来平衡I/O改善性能；
- 改善性能：对大表的查询、增加、修改等操作可以分解到表的不同分区来并行执行，可使运行速度更快；
- 分区对用户透明，最终用户感觉不到分区的存在。

是否应用分区表功能设计，可能参考以下几个因素：

- 大于2GB的表
- 含有1000万条记录以上的表，表中含有的数据越多，SQL操作的执行速度就会越慢。
- 将会含有大量数据的表。
- 强行拆分后可利于并行操作的表。
- 含有需要定期归档日志或删除部分的表。

对于数据量比较大的表，根据表数据的属性进行分区，以得到较好的性能。

- todo: 检查下面是否适用于 pgsql
- 如果表按某些字段进行增长，则采用按字段值范围进行 Range 范围分区。
- 如果表按某个字段的几个关键值进行分布，则采用 List 列表分区。
- 对于静态表，则采用 Hash 哈希分区或 List 列表分区。
- 在范围分区中，如果数据按某关键字段均衡分布，则采用子分区的复合分区方法。

### 1.6. 视图

无。

### 1.7. 物化视图

物化视图是包括一个查询结果的数据库对像，它是远程数据的的本地副本，或者用来生成基于数据表求和的汇总表。物化视图存储基于远程表的数据，也可以称为快照。

物化视图可以用于预先计算并保存表连接或聚集等耗时较多的操作的结果，这样，在执行查询时，就可以避免进行这些耗时的操作，而从快速的得到结果。物化视图有很多方面和索引很相似：使用物化视图的目的是为了提高查询性能；物化视图对应用透明，增加和删除物化视图不会影响应用程序中SQL语句的正确性和有效性；物化视图需要占用存储空间；当基表发生变化时，物化视图也应当刷新。

物化视图可以查询表，视图和其它的物化视图。

物化视图有一些优点：

- 能够提高查询速度，这主要是因为物化视图存储了实际的数据，其次具有查询重写功能。最后，物化视图具有实体表，你也可以在上面建立索引，总之大体上当作一个表用就可以了。
- 简化了开发任务,意思是开发的人员有的时候，无需直接关注部分sql的性能，而通过dba的努力，使用查询重写来完成性能的提升。
- 减少了工作量，因为物化视图可以定义两种刷新方式：立即刷新，按需刷新。所谓按需刷新就是你自己手动刷新，或者是定时刷新；所谓立即刷新，即视图主表发生变化的时候，视图立即刷新内容。  你可以根据自己的设备情况，应用情况和需求来控制刷新的方式。
- 刷新量的灵活限制，你可以快速是刷新（只刷新变化的），也可以全刷新。

### 1.8. 索引

对于查询中需要作为查询条件的字段，可以考虑建立索引。最终根据性能的需要决定是否建立索引。

对于复合索引，索引字段顺序比较关键，把查询频率比较高的字段排在索引组合的最前面。

### 1.9. 主键

关联表的父表要求有主健。

### 1.10. 外键

对于关联两个表的字段，一般应该分别建立主键、外键。实际是否建立外键，根据对数据完整性的要求决定。为了提高性能，要求对外健建立索引。

### 1.11. NULL 值

数据库中不建议出现可为空NULL字段。应该在sql建表脚本中明确指明使用缺省。由于NULL值在参加任何运算中，结果均为NULL，所以在应用程序中必须利用nvl()函数把可能为NULL值的字段或变量转换为非NULL的默认值。例如：NVL（sale,0）。

## 2. 命名规范

### 2.1. 命名原则

所有数据库元素遵循如下命名原则。

| 规则项       | 说明                                                                                                                                                                                                                                                                                                                                   |
| ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 字符         | 所有数据库对象采用 26 个英文字母（区分大小写）和 0-9 这十个自然数，加上下划线 _ 组成，共 63 个字符。不能出现其他字符（注释除外）。                                                                                                                                                                                                     |
| 语言         | 命名使用英文单词，尽量不使用数字或拼音。命名不允许使用中文或者特殊字符。当一个单词不能表达对象含义时，用词组组合，如果组合太长时，采用简写或缩写，缩写要基本能表达原单词的意义，譬如Incident缩写为Inci，Information缩写Info，Condition缩写为cond，Dictionary缩写Dict。当出现对象名重名时，是不同类型对象时，加类型前缀或后缀以示区别。 |
| 大小写       | 名称一律小写，不能加引号，以方便不同数据库移植，以及避免程序调用问题。                                                                                                                                                                                                                                                                 |
| 单复数       | 英文单词使用单数形式。                                                                                                                                                                                                                                                                                                                 |
| 单词分隔     | 命名的各单词之间可以使用下划线进行连接。                                                                                                                                                                                                                                                                                               |
| 保留字       | 命名不允许使用数据库或 SQL 的保留字、关键字。                                                                                                                                                                                                                                                                                          |
| 命名长度     | 表名、字段名、视图名长度应限制在 30 个字符内(含前缀)。变量名的长度限制为 29(不包括标识字符@)。除了前缀，组成单词一般控制在 3 个单词之内。如果有明确的英文缩写的可以采用英文缩写。                                                                                                                                                      |
| 命名         | 命名含义相同的使用同一个单词，避免一个语义出现多个英语单词。比如 telephone 在一个表中代表“电话号码”的意思，在另外一个表中就不能代表“手机号码”的意思。                                                                                                                                                                                  |
| 不同表的字段 | 用于相同内容的字段应该采用同样的名称，字段类型定义。                                                                                                                                                                                                                                                                                   |
| 重复性       | 命名不要与数据库的保留字重复，也不要跟系统里的对象重名，虽然在定义重复或者数据库访问时候不一定引起数据库系统的报错。                                                                                                                                                                                                                   |

### 2.2. 数据库实例

数据库实例明确约定如下：

### 2.3. 表空间

业务数据、大字段应分别位于不同的表空间。

表空间对应的操作系统目录名为表空间名，统一放在 `/pg/data/ts` 目录下。

表空间说明

| 表空间名  | 业务数据 | 操作系统目录             |
| --------- | -------- | ------------------------ |
| cisp_data | 业务数据 | /pg/data/pg_ts/cisp_data |
| cisp_lob  | 大字段   | /pg/data/pg_ts/cisp_lob  |

### 2.4. 数据库连接

命名格式：`DBL_<应用系统标志>`。

### 2.5. 表

todo 检查下面内容逻辑冲突

根据业务系统或业务模块对表名添加统一前缀区分。例如：`b_` 开头表示业务表，`r_` 开头表示关联表，`d_` 开头表示字典表。

- 使用单数形式的表名。
- 每个表应定义3-4个字符长的别名或缩写，并在当前命名空间中唯一。必要时，可用别名限定表中某些字段。表名缩写可参考如下规则：
  - APPLICATION = APPL (4)
  - APPLICATION_FUNCTION = APFU (2:2)
  - APPLICATION_FUNCTION_ROLE = APFR (2:1:1)
  - APPLICATION_FUNCTION_ROLE_BANANA = AFRB (1:1:1:1)
- 表中含有的单词建议用完整的单词。如果导致表名长度超过63个字符，则从最后一个单词开始，依次向前采用该单词的缩写。（如果没有约定的缩写，则采用该单词前4个字母来表示
- 可以根据系统业务划分，在表前加上适当的前缀（如GIS表）。
  - 命名格式：`[系统标识]_<表标识>`。
  - 其中，`[系统标识]`表示可选项，依据实际情况而增加；`<表标识>` 要求用与表意义相符或相近的英文单词或单词组合。

### 2.6. 视图

命名格式：`[系统标识]_<视图名称>`

其中`[系统标识]`是可选项，依据情况而增加,如空间数据库方面的视图用`<GIS>`；<视图标识>应由视图功能相近单词组成。

- 视图命名规则与表命名规则一致，视图名字长度不应超过30个字符，应直观可读。
- 视图也应该定义3-4个字符长度的缩写，以便需要的时候使用。
- 视图字段名直接从表派生的字段保留原名，非派生字段，以`<视图名缩写>_<标识名>`，如果含义明确`<视图名缩写>`可省略。

### 2.7. 字段

字段以英文单词或简写组成，以英文下划线“_”为分隔符。

表主键字段，采用ID或CODE（主要用于字典表）形式命名，并放于表定义最前面。

表外键字段，采用引用表的表名缩写加相关字段名。

外键字段命名格式：

- `<引用表缩写>_ID`
- `<引用表缩写>_<含义>_ID`（来源于同一主表的多个外键）

### 2.8. 主键约束

命名格式：`<表名>_<主键标识>_PK`

范例：

- EMP_ID_PK

如果表名过长，使用表名缩写。

### 2.9. 外键约束

命名格式：`<表名>_<引用表名>_FK。`

范例：

- EMP_EMP_ID_PK
- EMP_JOB_FK

如果有来源于同一主表的多个外键，则外键约束以 `<表名>_<引用表名>_<标识名>_FK` 形式命名。

其中

- `<表名>`：依赖表的缩写；
- `<引用表名>`：引用表的缩写；
- `<标识名>`：业务含义标识。

### 2.10. 唯一性约束（Constraint）

命名格式：`<表名缩写>_<UK标识>_UK`

范例：EMP_EMAIL_UK

`<表名缩写>`可以根据实际情况决定是否保留，但名字应直观可读。

### 2.11. NOT NULL 约束（Constraint）

命名格式：数据库自动生成非空约束名。

### 2.12. Check 约束（Constraint）

命名格式：数据库自动生成检查约束名。

### 2.13. 索引

命名格式：`<表名缩写>_<字段名>_IX`

范例：CUST_EMAIL_IX

多字段索引：`<表名缩写>_<含义>_IX`

其中`<含义>`可由多字段组合而成，即为`<Col1>_<Col2>_…_IX`，`<Col1>`是数据库表中（第一个）索引字段的名称或名称简写；`<Col2>`是数据库表中（第二个）索引字段的名称或名称简写；索引名的总长必需符合数据库的规定。

### 2.14. 函数

按业务操作命名函数，长度应符合数据库命名的总体规则。

## 3. 开发规范

SQL 代码编写遵循如下规则。

| 规则项   | 说明                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 字符类型 | 数据 SQL 中的字符类型数据应该统一使用单引号。特别对纯数字的字串，必须用单引号，否则会导致内部转换而引起性能问题或索引失效问题。利用trim(),lower()等函数格式化匹配条件。                                                                                                                                                                                                                                                                   |
| 复杂sql  | 对于非常复杂的sql（特别是有多层嵌套，带子句或相关查询的），应该先考虑是否设计不当引起的。对于一些复杂SQL可以考虑使用程序实现。                                                                                                                                                                                                                                                                                                            |
| 高效性   | 条件查询时，将高过滤的属性字段放在条件的左边。避免In子句：使用In 或 not In子句时，特别是当子句中有多个值时，且查询数据表数据较多时，速度会明显下降，应可采用连接查询或外连接查询来提高性能。避免嵌套的Select子句：这个实际上是In子句的特例。避免使用 `select *` 语句：如果不是必要取出所有数据，不要用*来代替，应给出字段列表。避免不必要的排序：不必要的数据排序大大降低系统性能。避免使用 not null条件：Not NULL 条件会使查询索引失效。 |
| 健壮性   | 使用Insert语句一定要给出插入值的字段列表，这样即使更改了表结构加了字段也不会影响现有系统的运行。                                                                                                                                                                                                                                                                                                                                          |
| 安全性   | Where条件：无论在使用Select,还是在使用破坏力极大的Update和Delete语句时，一定要检查Where条件判断的完整性，不要在运行时出现数据的重大丢失。如果不确定，最好先用Select语句带上相同条件来查一下结果集，以此来检验查询条件是否正确。                                                                                                                                                                                                           |

下述内容参考： https://developer.aliyun.com/article/60899

- 【强制】不要使用count(列名)或count(常量)来替代count(*)，count(*)就是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。说明：count(*)会统计NULL值（真实行数），而count(列名)不会统计。
- 【强制】count(多列列名)时，多列列名必须使用括号，例如count( (col1,col2,col3) )。注意多列的count，即使所有列都为NULL，该行也被计数，所以效果与count(*)一致。
- 【强制】count(distinct col) 计算该列的非NULL不重复数量，NULL不被计数。
- 【强制】count(distinct (col1,col2,...) ) 计算多列的唯一值时，NULL会被计数，同时NULL与NULL会被认为是想同的。
- 【强制】count(col)对“是NULL的col列”返回为0，而sum(col)则为NULL。
- 【强制】在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。
- 【强制】游标使用后要及时关闭。
- 【强制】两阶段提交的事务，要及时提交或回滚，否则可能导致数据库膨胀。
- 【强制】DDL操作必须设置锁等待，可以防止堵塞所有其他与该DDL锁对象相关的QUERY。
- 【强制】对象名（表名、列名、函数名、视图名、序列名、等对象名称）规范，对象名务必只使用小写字母，下划线，数字。不要以pg开头，不要以数字开头，不要使用保留字。
- 【强制】comment不要使用中文，query中别名不要使用中文。
- 【强制】不要使用delete 全表，性能很差，请使用truncate代替。
- 【强制】btree索引字段不建议超过2000字节，如果有超过2000字节的字段需要建索引，建议使用函数索引（例如哈希值索引），或者使用分词索引。
- 【强制】使用外键时，如果你使用的PG版本没有自动建立fk的索引，则必须要对foreign key手工建立索引，否则可能影响references列的更新或删除性能。
- 【强制】使用外键时，一定要设置fk的action，例如cascade，set null，set default。
- 【强制】数据订正时，删除和修改记录时，要先select，避免出现误删除，确认无误才能提交执行。
- 【强制】用户可以使用explain analyze查看实际的执行计划，但是如果需要查看的执行计划设计数据的变更，必须在事务中执行explain analyze，然后回滚。
- 【强制】应用程序一定要开启autocommit，同时避免应用程序自动begin事务，并且不进行任何操作的情况发生，某些框架可能会有这样的问题。
- 【强制】高并发的应用场合，务必使用绑定变量(prepared statement)，防止数据库硬解析消耗过多的CPU资源。
- 【强制】不要使用hash index，目前hash index不写REDO，在备库只有结构，没有数据，并且数据库crash后无法恢复。同时不建议使用unlogged table ，道理同上，但是如果你的数据不需要持久化，则可以考虑使用unlogged table来提升数据的写入和修改性能。
- 【强制】秒杀场景，一定要使用 advisory_lock先对唯一ID进行锁定，拿到AD锁再去对数据进行更新操作。 拿不到锁时，可以尝试重试拿锁。
- 【强制】对于频繁更新的表，建议建表时指定表的fillfactor=85，每页预留15%的空间给HOT更新使用。
- 【强制】在函数中，或程序中，不要使用count(*)判断是否有数据，很慢。 建议的方法是limit 1;
- 【强制】对于高并发的应用场景，务必使用程序的连接池，否则性能会很低下。如果程序没有连接池，建议在应用层和数据库之间架设连接池，例如使用pgbouncer或者pgpool-II作为连接池。
- 【强制】如何并行创建索引，不堵塞表的DML，创建索引时加CONCURRENTLY关键字，就可以并行创建，不会堵塞DML操作，否则会堵塞DML操作。
- 【强制】当业务有近邻查询的需求时，务必对字段建立GIST或SP-GIST索引，加速近邻查询的需求。
- 【强制】为数据库访问账号设置复杂密码。说明：密码由小写字母，数字、下划线组成、字母开头，字母或数字结尾，禁止123456，hello123等简单密码。
- 【强制】表结构中字段定义的数据类型与应用程序中的定义保持一致，表之间字段校对规则一致，避免报错或无法使用索引的情况发生。说明： 比如A表user_id字段数据类型定义为varchar，但是SQL语句查询为 where user_id=1234；
- 【强制】除非是ETL程序，否则应该尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
- 【强制】任何地方都不要使用 select * from t ，用具体的字段列表代替*，不要返回用不到的任何字段。另外表结构发生变化也容易出现问题。
- 【强制】避免频繁创建和删除临时表，以减少系统表资源的消耗，因为创建临时表会产生元数据，频繁创建，元数据可能会出现碎片。
- 【强制】业务系统，开发测试账号，不要使用数据库超级用户。非常危险。
- 【强制】必须选择合适的事务隔离级别，不要使用越级的隔离级别，例如READ COMMITTED可以满足时，就不要使用repeatable read和serializable隔离级别。
- 【推荐】多个业务共用一个PG集群时，建议为每个业务创建一个数据库。 如果业务之间有数据交集，或者事务相关的处理，强烈建议在程序层处理数据的交互。不能在程序中处理时，可以将多个业务合并到一个库，但是使用不同的schema将多个业务的对象分开来。
- 【推荐】应该为每个业务分配不同的数据库账号，禁止多个业务共用一个数据库账号。
- 【推荐】不需要精确分页数时，请使用快速评估分页数的方法。
- 【推荐】建议通过游标返回分页结果，避免越后面的页返回越慢的情况。
- 【推荐】可以预估SQL执行时间的操作，建议设置语句级别的超时，可以防止雪崩，也可以防止长时间持锁。
- 【推荐】建议有定期历史数据删除需求的业务，表按时间分区，删除时不要使用DELETE操作，而是DROP或者TRUNCATE对应的表。
- 【推荐】在发生主备切换后，新的主库在开放给应用程序使用前，建议使用pg_prewarm预热之前的主库shared buffer里的热数据。
- 【推荐】TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但是TRUNCATE是DDL，锁粒度很大，故不建议在开发代码中使用DDL语句，除非加了lock_timeout锁超时的会话参数或事务参数。
- 【推荐】PostgreSQL支持DDL事务，支持回滚DDL，建议将DDL封装在事务中执行，必要时可以回滚。
- 【推荐】如果用户需要在插入数据和，删除数据前，或者修改数据后马上拿到插入或被删除或修改后的数据，建议使用insert into .. returning ..; delete .. returning ..或update .. returning ..; 语法。减少数据库交互次数。
- 【推荐】如果对全表的很多字段有任意字段匹配的查询需求，建议使用行级别全文索引，或行转数组的数组级别索引。
- 【推荐】设计时应尽可能选择合适的数据类型，能用数字的坚决不用字符串，能用树类型的，坚决不用字符串。 使用好的数据类型，可以使用数据库的索引，操作符，函数，提高数据的查询效率。
- 【推荐】对于网络复杂并且RT要求很高的场景，如果业务逻辑冗长，应该尽量减少数据库和程序之间的交互次数，尽量使用数据库存储过程，或内置的函数。
- 【推荐】树形查询应该使用递归查询，尽量减少数据库的交互或JOIN。
- 【推荐】应用应该尽量避免使用数据库触发器，这会使得数据处理逻辑复杂，不便于调试。
- 【推荐】未使用的大对象，一定要同时删除数据部分，否则大对象数据会一直存在数据库中，与内存泄露类似。
- 【推荐】如果用户经常需要访问一张大表的某些数据，为了提升效率可以使用索引，但是如果这个数据还需要被用于更复杂的与其他表的JOIN操作，则可以使用物化视图来提升性能。同时物化视图还可以被用于OLAP场景，例如统计后的数据可以固化到物化视图中，以便快速的检索。
- 【推荐】不建议对宽表频繁的更新，原因是PG目前的引擎是多版本的，更新后会产生新的版本，如果对宽表的某几个少量的字段频繁更新，其实是存在写放大的。
- 【推荐】对于经常使用表达式作为查询条件的语句，可以使用表达式或函数索引加速查询。
- 【推荐】如果需要调试较为复杂的逻辑时，不建议写成函数进行调试，可以使用plpgsql的online code.
- 【推荐】当业务有中文分词的查询需求时，建议使用PostgreSQL的分词插件zhparser或jieba，用户还可以通过接口自定义词组。建议在分词字段使用gin索引，提升分词匹配的性能。
- 【推荐】当用户有规则表达式查询，或者文本近似度查询的需求时，建议对字段使用trgm的gin索引，提升近似度匹配或规则表达式匹配的查询效率，同时覆盖了前后模糊的查询需求。
- 【推荐】当用户有prefix或者 suffix的模糊查询需求时，可以使用索引，或反转索引达到提速的需求。
- 【推荐】用户应该对频繁访问的大表（通常指超过8GB的表）进行分区，从而提升查询的效率，以及更新的效率，备份与恢复的效率，建索引的效率等等。
- 【推荐】应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
- 【推荐】尽量使用数组变量来代替临时表。如果临时表有非常庞大的数据时，才考虑使用临时表。
- 【推荐】对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。使用explain可以查看执行计划，如果发现执行计划不优，可以通过索引或者调整QUERY的写法解决。

## 4. 数据类型使用约定

| 数据类型   | 说明                                                                                                                                                                           |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 布尔型     | PostgreSQL 支持 SQL 标准的 boolean 数据类型。                                                                                                                                  |
| 字符型     | 固定长度的字串类型采用 char，长度不固定的字串类型采用 varchar。避免在长度不固定的情况下采用 char 类型。1GB 以上的字符型数据使用 text。                                         |
| 数字型     | 数字型字段尽量采用长度为 4 字节的 int 类型，特殊情况下考虑使用 8 字节的 bigint。                                                                                               |
| 日期和时间 | 系统时间：由数据库产生的系统时间首选数据库的日期型，如 timestamp 类型。外部时间：由数据导入或外部应用程序产生的日期时间类型采用 varchar 类型，数据格式采用：YYYYMMDDHH24MISS。 |
| 几何类型   | 包括了点（point），直线（line），线段（lseg），路径（path），多边形（polygon），圆（cycle）等类型。                                                                            |
| 大字段     | 如无特别需要，避免使用大字段（blob, clob, text, image 等）                                                                                                                     |
| json       | 用于存储 json 类型的数据。                                                                                                                                                     |
| UUID       | 可以用作业务表主键，基本字典表中尽量不使用 UUID 作为主键。                                                                                                                     |

## 5. 参考资料

1. https://developer.aliyun.com/article/60899
2. https://github.com/dongxuyang1985/postgresql_dev_guide
