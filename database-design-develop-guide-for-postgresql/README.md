# PostgreSQL 数据库设计和开发指南

> 适用于 PostgreSQL 11 及以上版本

- [1. 设计原则](#1-设计原则)
  - [1.1. 关于范式](#11-关于范式)
  - [1.2. 字符集和编码](#12-字符集和编码)
  - [1.3. 数据库服务器和数据库](#13-数据库服务器和数据库)
  - [1.4. 表空间](#14-表空间)
  - [1.5. Schema](#15-schema)
  - [1.6. 表](#16-表)
  - [1.7. 分区表](#17-分区表)
  - [1.8. 视图](#18-视图)
  - [1.9. 物化视图](#19-物化视图)
  - [1.10. 索引](#110-索引)
  - [1.11. 主键](#111-主键)
  - [1.12. 外键](#112-外键)
  - [1.13. 数值](#113-数值)
- [2. 命名规范](#2-命名规范)
  - [2.1. 命名原则](#21-命名原则)
  - [2.2. 数据库](#22-数据库)
  - [2.3. 数据库连接](#23-数据库连接)
  - [2.4. 表空间](#24-表空间)
  - [2.5. Schema](#25-schema)
  - [2.6. 表和字段](#26-表和字段)
    - [2.6.1. 表](#261-表)
    - [2.6.2. 字段](#262-字段)
  - [2.7. 分区表](#27-分区表)
  - [2.8. 视图和视图字段](#28-视图和视图字段)
  - [2.9. 主键约束](#29-主键约束)
  - [2.10. 外键约束](#210-外键约束)
  - [2.11. 唯一性约束（Constraint）](#211-唯一性约束constraint)
  - [2.12. NOT NULL 约束（Constraint）](#212-not-null-约束constraint)
  - [2.13. Check 约束（Constraint）](#213-check-约束constraint)
  - [2.14. 索引](#214-索引)
  - [2.15. 序列](#215-序列)
  - [2.16. 函数](#216-函数)
- [3. 开发规范](#3-开发规范)
  - [3.1. 德哥的 PostgreSQL 数据库开发规范](#31-德哥的-postgresql-数据库开发规范)
  - [3.2. 补充约定](#32-补充约定)
- [4. 数据类型使用约定](#4-数据类型使用约定)
- [5. 参考资料](#5-参考资料)

## 1. 设计原则

### 1.1. 关于范式

如无性能上的必须原因，应该使用关系数据库理论，达到较高的范式匹配（3NF），避免数据冗余，明确数据间的关系。

如果对性能有较高要求，或者在特定场景达成业务目标的便利性收益高于数据管理影响，可以设计适当的突破范式要求。

### 1.2. 字符集和编码

应当采用 `Unicode` 字符集和 `UTF8` 编码，此为 PostgreSQL 数据库服务器默认设置，并且，如果在创建数据库（实例）时没有特别指定，也将是数据库（实例）的默认设置。

如果有强烈的中华多文字支持要求，如简体汉字、繁体汉字、少数民族文字、日文、韩文等，可以使用 `GB18030` 字符集和编码，不建议使用 `GB2312`、`GBK`。

### 1.3. 数据库服务器和数据库

一个操作系统中只部署 1 个数据库服务器软件。

一个数据库服务器中可以创建多个数据库。

### 1.4. 表空间

对于 PostgreSQL 来说，在 **同一个** 磁盘分区上建立多个表空间没有太多实际意义。

从合理利用磁盘性能和空间角度，可以分别建立不同的表空间，如：

- 在高 IO 性能的磁盘分区上创建的表空间，可以用来存放经常访问的表和索引。
- 在便宜和较低 IO 性能的磁盘分区上创建的表空间，可以用来存放很少使用或性能要求不高的归档数据的表。

对于容器部署的数据库，容器内可以使用默认表空间 `pg_default`，并映射到容器外宿主机的特定路径下。

非容器部署的数据库，建议在指定的路径下创建表空间。

多个数据库可以共用同一个表空间。

> 注意：
> PostgreSQL 中的表空间与 Oracle 不一样，创建 PostgreSQL 表空间只要指定名称与数据库文件的目录，而没有具体的大小。
> PostgreSQL 表空间不适用“自动扩容”这个概念，存储不足时可以通过扩展表空间所在存储容量，或者在不同存储设备/分区中新建表空间并指定新表使用新表空间来达到扩容目的。

### 1.5. Schema

建议为子系统、业务模块或用户分配对应的 schema。

不建议使用 `public` schema，即便是不同业务共享的对象也不建议选择 `public` schema。

### 1.6. 表

无。

### 1.7. 分区表

分区表有一些优点:

- 改善性能：对大表的查询、更新、备份恢复、建索引等操作可以分解到表的不同分区来并行执行，可使效率更高；
- 维护轻松：如果需要重建表，独立管理每个分区比管理单个大表要轻松得多；
- 均衡I/O：可以把表的不同分区分配到不同的磁盘来平衡I/O改善性能；
- 增强可用性：如果表的一个分区由于系统故障而不能使用，表的其余好的分区仍然可以使用；
- 减少关闭时间：如果系统故障只影响表的一部分分区，那么只有这部分分区需要修复，故能比整个大表修复花的时间更少；
- 分区对用户透明，最终用户感觉不到分区的存在。

是否应用分区表功能设计，可能参考以下几个因素：

- 大于 2GB 的表
- 含有 1000 万条记录以上的表
- 将会含有大量数据的表。
- 强行拆分后可利于并行操作的表。
- 含有需要定期归档日志或删除部分的表。

对于数据量比较大的表，根据表数据的属性进行分区，以得到较好的性能。

- 如果表按某些字段进行增长，则采用按字段值范围进行 Range 范围分区。
- 如果表按某个字段的几个关键值进行分布，则采用 List 列表分区。
- 对于静态表，则采用 Hash 哈希分区或 List 列表分区。
- 在范围分区中，如果数据按某关键字段均衡分布，则采用子分区的复合分区方法。

### 1.8. 视图

无。

### 1.9. 物化视图

物化视图是包括一个查询结果的数据库对像，它是远程数据的的本地副本，或者用来生成基于数据表求和的汇总表。物化视图存储基于远程表的数据，也可以称为快照。

物化视图可以用于预先计算并保存表连接或聚集等耗时较多的操作的结果，这样在执行查询时，就可以避免进行这些耗时的操作，而从快速的得到结果。

物化视图有很多方面和索引很相似：

- 使用物化视图的目的是为了提高查询性能；
- 物化视图对应用透明，增加和删除物化视图不会影响应用程序中SQL语句的正确性和有效性；
- 物化视图需要占用存储空间；
- 当基表发生变化时，物化视图也应当刷新。

物化视图可以查询表、视图和其它的物化视图。

物化视图有一些优点：

- 能够提高查询速度，这主要是因为物化视图存储了实际的数据，其次具有查询重写功能。最后，物化视图具有实体表，你也可以在上面建立索引，总之大体上当作一个表用就可以了。
- 简化了开发任务,意思是开发的人员有的时候，无需直接关注部分sql的性能，而通过dba的努力，使用查询重写来完成性能的提升。
- 减少了工作量，因为物化视图可以定义两种刷新方式，可以根据设备情况、应用情况和需求来控制刷新的方式。
  - 立即刷新：即视图主表发生变化的时候，视图立即刷新内容
  - 按需刷新：就是手动刷新，或者是定时刷新
- 刷新量的灵活限制，你可以快速是刷新（只刷新变化的），也可以全刷新。

### 1.10. 索引

对于查询中需要作为查询条件的字段，可以考虑建立索引。最终根据性能的需要决定是否建立索引。

对于复合索引，索引字段顺序比较关键，把查询频率比较高的字段排在索引组合的最前面。

### 1.11. 主键

关联表的父表要求有主健。

### 1.12. 外键

对于关联两个表的字段，一般应该分别建立主键、外键，实际是否建立外键，根据对数据完整性的要求决定。

为了提高性能，要求对外键字段建立索引。

### 1.13. 数值

- 标识或标志

  如非确实必要，避免一个字段中存储多个标志的做法。如 `11101` 数值中每个数字分别代表 5 个标志位的取值。这对数据库查询来说往往是增加复杂度，降低性能的地方。

- NULL 值

  数据库中不建议出现可为空NULL字段。应该在sql建表脚本中明确指明使用缺省。由于NULL值在参加任何运算中，结果均为NULL，所以在应用程序中必须利用nvl()函数把可能为NULL值的字段或变量转换为非NULL的默认值。例如：NVL（sale,0）。

## 2. 命名规范

### 2.1. 命名原则



所有数据库对象遵循如下命名原则。

| 规则项   | 说明                                                                                                                                                                               |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 字符     | 所有对象名采用 26 个英文字母（区分大小写）和 0-9 这十个自然数，加上下划线 _ 组成，共 63 种字符，不能出现其他字符（注释除外）。                                                     |
| 大小写   | 名称统一小写（或统一大写）且不能加引号，以方便不同数据库移植，以及避免 SQL 编写时强制区分大小写。                                                                                  |
| 单复数   | 英文单词使用单数形式。                                                                                                                                                             |
| 保留字   | 命名不要以 `pg` 开头，不允许使用数据库或 SQL 的保留字、关键字，不要与数据库内置对象重名。                                                                                          |
| 命名     | 命名推荐使用英文单词，可以使用拼音首字母组合。命名不要以数字开头，但可以数字结尾。                                                                                                 |
| 单词组合 | 当一个单词不能表达对象含义时，使用单词组合，单词之间使用下划线连接。除了前缀，组成单词一般控制在 3 个单词之内。                                                                    |
| 命名长度 | 表名、字段名、函数名、视图名、序列名长度应限制在 30 个字符内(含前缀)。变量名的长度限制为 29 （不包括标识字符 `@`）。命名过长时，单词采用简写或缩写，缩写要基本能表达原单词的意义。 |
| 语义唯一 | 使用同一个名称命名相同含义的对象，避免一个语义出现多个英语单词。比如 telephone 在一个表中代表“电话号码”的意思，在另外一个表中就不能代表“手机号码”的意思。                          |

具体项目中应当约定常见的单词缩写。

todo

| 单词          | 缩写  | 含义     |
| ------------- | ----- | -------- |
| information   | info  | 信息     |
| dictionary    | dict  | 字典     |
| condition     | cond  | 条件     |
| event         | evt   | 事件     |
| incident      | inci  | 事故     |
| emergency     | emer  | 应急     |
| organization  | org   | 组织机构 |
| facility      | facil | 设施     |
| production    | prod  | 生产     |
| communication | comm  | 通信     |
| government    | gov   | 政府     |
| ecological    | eco   | 生态     |

### 2.2. 数据库

数据库命名格式：`<应用系统标识>_db`

范例：

- oa_db
- oa_hr_db

数据库名不超过 20 个字符。

### 2.3. 数据库连接

连接命名格式：`conn_<应用系统标识>`。

### 2.4. 表空间

> 表空间的名称不能以 'pg_' 开头，它们是系统表空间的保留名称。

表空间命名格式：`spc_<应用系统标识>`

范例：

- spc_oa
- spc_oa_attachment

表空间对应的操作系统目录名为表空间名，建议放在 `/data/pg_data/*` 目录下，如：

| 表空间名          | 用途             | 操作系统路径                    |
| ----------------- | ---------------- | ------------------------------- |
| spc_oa            | 业务数据         | /data/pg_data/spc_oa            |
| spc_oa_attachment | 非关键的附件数据 | /data/pg_data/spc_oa_attachment |

### 2.5. Schema

Schema 命名格式：`<应用系统标识>_<业务标识>`

范例：

- oa_hr
- oa_sale
- oa_common（用于归集共用表）

### 2.6. 表和字段

#### 2.6.1. 表

表命名遵循以下约定。

- 表名应限制在 30 个字符内（含前缀）。
- 表名中的单词使用单数形式。
- 表名中可以有一个或多个单词，单词间以下划线连接。
- 首选完整的单词，长度超限时采用单词缩写。如果没有约定的缩写，则采用该单词前 4 个字母来表示。
- 如果“表名+字段名”长度超过 60 个字符，则从最后一个单词开始，依次向前采用该单词的缩写。

表的别名或缩写约定为 3-4 个字符，并在当前命名空间中唯一。表名缩写可参考如下规则：

- APPLICATION = APPL (4)
- APPLICATION_FUNCTION = APFU (2:2)
- APPLICATION_FUNCTION_ROLE = APFR (2:1:1)
- APPLICATION_FUNCTION_ROLE_BANANA = AFRB (1:1:1:1)

> 必要时，可用别名限定表中的字段。

可以根据需要对表名添加统一前缀区分。

todo 需要讨论

| 前缀/后缀 | 含义       |
| --------- | ---------- |
| `b_*`     | 业务表     |
| `r_*`     | 关联表     |
| `d_*`     | 字典表     |
| `tmp_*`   | 临时表     |
| `g_*_p`   | 空间表，点 |
| `g_*_l`   | 空间表，线 |
| `g_*_a`   | 空间表，面 |

在没有使用 schema 的情况下，可以根据系统业务划分，在表名中加上适当小节，如：

- b_hr_employee
- b_hr_training
- b_sale_order

#### 2.6.2. 字段

字段以英文单词或简写组成，以英文下划线“_”为分隔符。

主键字段，采用 `id` 或 `code`（主要用于字典表）命名，放于表定义最前面。

引用字典表的外键字段名应该以 `code` 结尾。

引用业务表的外键字段采用引用表的表名缩写加相关字段名（一般为 `id`），命名格式：

- `<引用表缩写>_id`
- `<引用表缩写>_<含义>_id`（来源于同一主表的多个外键）

### 2.7. 分区表

分区表命名格式：`<主表名>_<分区逻辑>`

范例：

按年分区的主表如果为 `b_post`, 则子表为 `b_post_2021`，`b_post_2022`。

### 2.8. 视图和视图字段

视图命名规则与表命名规则基本一致，需要额外注意以下约定。

视图命名格式：`v_<视图标识>`

- 视图也可以定义 3-4 个字符长度的缩写，以便需要的时候使用。
- 视图字段名，直接从表派生的字段保留原名，非派生字段以`<视图名缩写>_<标识名>`，如果含义明确`<视图名缩写>`可省略。

### 2.9. 主键约束

命名格式：`pk_<表名>`

范例：

- pk_employee

### 2.10. 外键约束

命名格式：`fk_<表名>_<引用表名>`

范例：

- fk_salary_employee

如果有来源于同一主表的多个外键，则

命名格式：`fk_<表名>_<引用表名>_<字段名>`

### 2.11. 唯一性约束（Constraint）

命名格式：`uk_<表名缩写>_<UK标识>`

范例：uk_employee_email

`<表名缩写>`可以根据实际情况决定是否保留，但名字应直观可读。

### 2.12. NOT NULL 约束（Constraint）

命名格式：数据库自动生成非空约束名。

### 2.13. Check 约束（Constraint）

命名格式：数据库自动生成检查约束名。

### 2.14. 索引

命名格式：`idx_<表名缩写>_<字段名>`

范例：idx_employee_email

多字段索引：`idx_<表名缩写>_<含义>`

其中`<含义>`可由多字段组合而成,即为 `idx_<表名缩写>_<Col1>_<Col2>_…`，
`<Col1>`是数据库表中（第一个）索引字段的名称或名称简写；
`<Col2>`是数据库表中（第二个）索引字段的名称或名称简写；
索引名的总长必需符合数据库的规定。

### 2.15. 序列

序列命名规则：`seq_<表名>`

范例：seq_employee

### 2.16. 函数

按业务操作命名函数，下划线连接单词，长度应符合数据库命名的总体规则。

## 3. 开发规范

### 3.1. 德哥的 PostgreSQL 数据库开发规范

推荐参考

[德哥的 PostgreSQL 数据库开发规范](https://developer.aliyun.com/article/60899)

[本地 pdf](./postgresql-developer-guide.pdf)

### 3.2. 补充约定

SQL 代码编写遵循如下约定。

- 字符类型
  
  数据 SQL 中的字符类型数据应该统一使用单引号。
  特别对纯数字的字串，必须用单引号，否则会导致内部转换而引起性能问题或索引失效问题。
  可以利用 `trim()`，`lower()` 等函数格式化匹配条件。

- 复杂 SQL
  
  对于非常复杂的 SQL（特别是有多层嵌套，带子句或相关查询的），应该先考虑是否设计不当引起的。

- 高效性

  条件查询时，将高过滤的属性字段放在条件的左边。
  避免In子句：使用 In 或 Not In 子句时，特别是当子句中有多个值时，且查询数据表数据较多时，速度会明显下降，应可采用连接查询或外连接查询来提高性能。
  避免嵌套的 `select` 子句：这个实际上是In子句的特例。
  避免使用 `select *` 语句：如果不是必要取出所有数据，不要用 * 来代替，应给出字段列表。
  避免不必要的排序：不必要的数据排序大大降低系统性能。
  避免使用 `not null` 条件：Not NULL 条件会使查询索引失效。

- 健壮性

  使用 Insert 语句一定要给出插入值的字段列表，这样即使更改了表结构加了字段也不会影响现有系统的运行。

- 安全性

  Where条件：无论在使用 Select 还是在使用破坏力极大的 Update 和 Delete 语句时，一定要检查 Where 条件判断的完整性，不要在运行时出现数据的重大丢失。
  如果不确定，最好先用 Select 语句带上相同条件来查一下结果集，以此来检验查询条件是否正确。

## 4. 数据类型使用约定

| 数据类型    | 说明                                                                                                                                                                           |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 布尔型      | PostgreSQL 支持 SQL 标准的 boolean 数据类型。                                                                                                                                  |
| 字符型      | 固定长度的字串类型采用 char，长度不固定的字串类型采用 varchar。避免在长度不固定的情况下采用 char 类型。1GB 以上的字符型数据使用 text。                                         |
| 数字型      | 数字型字段尽量采用长度为 4 字节的 int 类型，特殊情况下考虑使用 8 字节的 bigint。                                                                                               |
| 日期和时间  | 系统时间：由数据库产生的系统时间首选数据库的日期型，如 timestamp 类型。外部时间：由数据导入或外部应用程序产生的日期时间类型采用 varchar 类型，数据格式采用：YYYYMMDDHH24MISS。 |
| UUID        | 可以用作业务表主键，字典表中尽量不使用 UUID 作为主键。                                                                                                                         |
| BLOB        | PostgreSQL 处理 LOB 数据有些特殊，与 JPA 有逻辑差异，建议避免使用 blob 类型；PostgreSQL 中没有 CLOB， NCLOB 类型。                                                             |
| json, jsonb | 用于存储 json 类型的数据。                                                                                                                                                     |
| 几何类型    | 使用 PostGIS 为表添加名为 `shape` 的几何字段。                                                                                                                                 |

> PostgreSQL 中没有 CLOB，NCLOB 等类型, 对应有 TEXT 等。

更多数据类型信息参考：https://www.runoob.com/postgresql/postgresql-data-type.html

## 5. 参考资料

1. PostgreSQL 数据库开发规范：https://developer.aliyun.com/article/60899
2. PostgreSQL 的表空间：https://developer.aliyun.com/article/661642
3. 字符集和字符编码：https://www.runoob.com/w3cnote/charset-encoding.html
4. PostgreSQL 数据类型：https://www.runoob.com/postgresql/postgresql-data-type.html
5. PostgreSQL 关于CLOB, BLOB及JSON类型的处理：https://www.cnblogs.com/wggj/p/7809832.html
6. Geometry - PostgreSQL ＆ PostGIS 的使用：https://www.cnblogs.com/oddcat/articles/10722065.html
7. https://github.com/dongxuyang1985/postgresql_dev_guide
